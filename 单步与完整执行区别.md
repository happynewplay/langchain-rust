# Agent 两种执行模式详解

## 🔍 两种执行模式概述

在 langchain-rust 中，Agent 有两种核心执行模式：

### 1. 单步执行模式 (Single-Step Execution)
- **返回**: `AgentEvent::Action`
- **特点**: 每次只规划一个动作，需要外部执行器协调
- **控制**: 外部控制执行流程

### 2. 完整执行模式 (Complete Execution)  
- **返回**: `AgentEvent::Finish`
- **特点**: 内部处理完整的执行循环，直接返回最终结果
- **控制**: Agent内部控制执行流程

## 🎯 设计理念与使用场景

### 单步执行模式 (Action-based)

#### 🔧 使用场景

1. **复杂工作流编排**
```rust
// 示例：多Agent协作场景
let action = agent.plan(&steps, input).await?;
match action {
    AgentEvent::Action(actions) => {
        for action in actions {
            // 可以在这里添加自定义逻辑
            log_action(&action);
            validate_action(&action)?;
            
            // 执行工具
            let result = execute_tool(&action).await?;
            
            // 可以修改或过滤结果
            let processed_result = process_result(result);
            steps.push((action, processed_result));
        }
    }
}
```

2. **人工干预和监督**
```rust
// 在每个步骤之间允许人工干预
let action = agent.plan(&steps, input).await?;
if requires_human_approval(&action) {
    let approved = ask_human_approval(&action).await?;
    if !approved {
        return Err("Action rejected by human");
    }
}
```

3. **调试和监控**
```rust
// 详细的执行监控
let action = agent.plan(&steps, input).await?;
match action {
    AgentEvent::Action(actions) => {
        for action in actions {
            println!("🔧 Executing: {} with input: {}", action.tool, action.tool_input);
            let start = Instant::now();
            let result = execute_tool(&action).await?;
            println!("✅ Completed in {:?}: {}", start.elapsed(), result);
        }
    }
}
```

4. **条件执行和分支逻辑**
```rust
// 根据条件选择不同的执行路径
let action = agent.plan(&steps, input).await?;
match action {
    AgentEvent::Action(actions) => {
        for action in actions {
            if action.tool == "dangerous_operation" && !safety_check() {
                // 跳过危险操作
                steps.push((action, "Skipped for safety".to_string()));
                continue;
            }
            let result = execute_tool(&action).await?;
            steps.push((action, result));
        }
    }
}
```

#### ✅ 优点

1. **精细控制**: 可以在每个步骤之间插入自定义逻辑
2. **可观测性**: 完全可见的执行过程
3. **可中断性**: 可以在任何步骤暂停或修改执行
4. **灵活性**: 支持复杂的条件逻辑和分支
5. **安全性**: 可以在执行前验证每个动作

### 完整执行模式 (Finish-based)

#### 🔧 使用场景

1. **简单任务执行**
```rust
// 直接获取结果，无需复杂控制
let result = agent.invoke(input).await?;
println!("Result: {}", result);
```

2. **批量处理**
```rust
// 处理大量简单任务
for task in tasks {
    let result = agent.invoke(task).await?;
    results.push(result);
}
```

3. **API服务**
```rust
// Web API 端点
async fn handle_request(input: String) -> Result<String, Error> {
    agent.invoke(prompt_args!{"input" => input}).await
}
```

4. **嵌入式使用**
```rust
// 作为更大系统的一个组件
struct DataProcessor {
    analysis_agent: Agent,
}

impl DataProcessor {
    async fn analyze(&self, data: &str) -> Result<String, Error> {
        // 简单直接的调用
        self.analysis_agent.invoke(prompt_args!{"data" => data}).await
    }
}
```

#### ✅ 优点

1. **简单易用**: 一次调用获得结果
2. **性能优化**: 减少外部协调开销
3. **封装性**: 隐藏内部执行细节
4. **可靠性**: 内部处理所有异常情况
5. **易于集成**: 符合函数式编程范式

## 🏗️ 架构设计优势

### 1. 分层抽象

```rust
// 高层抽象 - 完整执行
let result = agent.invoke(input).await?;

// 低层控制 - 单步执行  
loop {
    match agent.plan(&steps, input).await? {
        AgentEvent::Action(action) => { /* 自定义处理 */ }
        AgentEvent::Finish(result) => break result,
    }
}
```

### 2. 组合模式

```rust
// AgentExecutor 组合了两种模式
impl AgentExecutor {
    // 内部使用单步执行模式实现完整执行
    async fn invoke(&self, input: PromptArgs) -> Result<String, Error> {
        let mut steps = Vec::new();
        loop {
            match self.agent.plan(&steps, input.clone()).await? {
                AgentEvent::Action(actions) => {
                    // 执行工具
                    for action in actions {
                        let result = self.execute_tool(&action).await?;
                        steps.push((action, result));
                    }
                }
                AgentEvent::Finish(finish) => {
                    return Ok(finish.output);
                }
            }
        }
    }
}
```

### 3. 策略模式

不同的执行器可以实现不同的策略：

```rust
// 标准执行器
struct StandardExecutor;

// 流式执行器  
struct StreamingExecutor;

// 人工监督执行器
struct HumanSupervisedExecutor;

// MCP执行器
struct McpExecutor;
```

## 🔄 实际应用示例

### Team Agent 中的应用

```rust
// Team Agent 使用单步执行模式来协调子Agent
async fn execute_child_agent(&self, child: &ChildAgent, input: PromptArgs) -> Result<String> {
    let mut steps = Vec::new();
    let mut iteration = 0;
    
    loop {
        if iteration >= MAX_ITERATIONS {
            return Err("Max iterations exceeded");
        }
        
        match child.agent.plan(&steps, input.clone()).await? {
            AgentEvent::Finish(finish) => {
                return Ok(finish.output);
            }
            AgentEvent::Action(actions) => {
                // Team Agent 控制工具执行
                for action in actions {
                    // 可以添加团队级别的逻辑
                    let result = self.execute_with_team_context(&action).await?;
                    steps.push((action, result));
                }
            }
        }
        iteration += 1;
    }
}
```

### Human Agent 中的应用

```rust
// Human Agent 在每个Action前检查是否需要人工干预
async fn execute_with_intervention(&self, input: PromptArgs) -> Result<String> {
    let mut steps = Vec::new();
    
    loop {
        match self.agent.plan(&steps, input.clone()).await? {
            AgentEvent::Action(actions) => {
                for action in actions {
                    // 检查是否需要人工干预
                    if self.should_intervene(&action) {
                        let human_input = self.get_human_input(&action).await?;
                        if let Some(override_result) = human_input {
                            steps.push((action, override_result));
                            continue;
                        }
                    }
                    
                    let result = self.execute_tool(&action).await?;
                    steps.push((action, result));
                }
            }
            AgentEvent::Finish(finish) => {
                return Ok(finish.output);
            }
        }
    }
}
```

## 🎯 选择指南

### 何时使用单步执行模式

- ✅ 需要精细控制执行流程
- ✅ 需要人工干预或监督
- ✅ 需要复杂的条件逻辑
- ✅ 需要详细的执行监控
- ✅ 构建复杂的Agent编排系统

### 何时使用完整执行模式

- ✅ 简单的任务执行
- ✅ API服务和Web应用
- ✅ 批量处理场景
- ✅ 嵌入式使用
- ✅ 快速原型开发

## 🚀 性能考虑

### 单步执行模式
- **优势**: 可以优化每个步骤
- **劣势**: 外部协调开销
- **适用**: 复杂逻辑，少量调用

### 完整执行模式  
- **优势**: 减少协调开销
- **劣势**: 内部优化空间有限
- **适用**: 简单逻辑，大量调用

## 🎉 总结

这种双模式设计体现了优秀的软件架构原则：

1. **单一职责**: 每种模式专注于特定场景
2. **开放封闭**: 可扩展但不需修改核心
3. **组合优于继承**: 通过组合实现复杂功能
4. **分层抽象**: 提供不同层次的抽象
5. **灵活性**: 满足从简单到复杂的各种需求

这种设计让 langchain-rust 既能处理简单的AI任务，也能构建复杂的多Agent系统，是一个非常优雅和实用的架构选择！🎊
